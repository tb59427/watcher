/*
 * this little pgm watches a number of (max 200) directories for newly appearing files
 * appearing files are assumed to be jpg images from a webcam
 *
 * Once a new file is detected a thumbnail is generated and called whatever is defined in THUMB
 * and a file (name defined in BIGPIC) is generated.
 * if no blurring is needed for the full picture, BIGPIC is generated by a copy
 * if blurring is needed, BIGPIC is generated by blurring the original
 * Blurring is determined by the existence of a filename defined in BLURMASK containing a boolean
 * blurmask to be used in convert commands
 * 
 * So if you need to blur (portions of) an image before using it publicly, create a boolean 
 * blurmask (jpeg) for that image and place it in the directory where your webcams put new images
 *
 * A lot of sanity checks are missing and risky things are done. So make sure you run this
 * in a controlled and safe environment:
 *     - it is assumed new file are jpeg images
 *     - copy and convert commands are issued using system()
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/inotify.h>
#include <limits.h>
#include <dirent.h>
#include <unistd.h>
 
#define MAX_EVENTS 1024 		/*Max. number of events to process at one go*/
#define LEN_NAME 16 			/*Assuming that the length of the filename won't exceed 16 bytes*/
#define EVENT_SIZE  ( sizeof (struct inotify_event) ) /*size of one event*/
#define BUF_LEN     ( MAX_EVENTS * ( EVENT_SIZE + LEN_NAME )) /*buffer to store the data of events*/
#define BIGPIC "bigpic.jpg"       	/* name of big picture grabbed from wordpress */
#define THUMB "thumbnail.jpg"     	/* name of thumbnail file */
#define CONVERT "/usr/bin/convert "  	/* jpeg image converter */
#define CONVERTOPTIONS " -scale 35% "  	/* Option for image converter to reduct image to 35% size */
#define CP "/bin/cp "      		/* Copy Shell Command plus blank at the end */
#define BLURMASK	"blurmask.jpg"	/* blur mask if image needs blurred areas */
#define BLUROPTIONS	"-compose blur -define compose:args=3 -composite"
#define BLURREDIMG	"blurredimg.jpg"



 
int main( int argc, char **argv ) 
{
  int length, i = 0, wd, j;
  int fd;
 
  char buffer[BUF_LEN];
  char command[200];
  char blurcmd[200];
  char dirnames[200][200];
  char blurmask[200][200];
  int  blurcheck[200];
  char blurfile[200];
  struct stat statbuf;

  
  if (argc < 2 || strcmp(argv[1], "--help") == 0) {
      printf ("%s pathname ....\n", argv[0]);
      exit(-1);
  }
 
  /* Initialize Inotify*/
  fd = inotify_init();
  if ( fd < 0 ) {
    perror( "Couldn't initialize inotify");
  }
 
  /* add watch to a directory, remember directory and check blurring */
  for (j=1; j< argc; j++) {
      wd = inotify_add_watch(fd, argv[j], IN_CLOSE_WRITE); 
 
      if (wd == -1) {
        printf("Couldn't add watch to %s\n",argv[j]);
      }
      else {
	strcpy ( dirnames[wd], argv[j]);
        printf("Watching:: %s wd=%d\n",dirnames[wd],wd);

	/* check for blurring, by trying to open a a file with the blurmask */
	strcpy ( blurfile, argv[j]);
	strcat (blurfile, "/");
	strcat ( blurfile, BLURMASK);
        blurcheck[wd] = 0;

	/* if open succeeds, remember full path of blurmask for later use */
	if (stat (blurfile, &statbuf) == 0) {
	   blurcheck[wd] = 1;
	   strcpy (blurmask[wd], blurfile);
	   printf ("file needs blurring\n");
	}
      }
  }
 
  /* do it forever*/
  while(1) {
    
      i = 0;
      length = read( fd, buffer, BUF_LEN );  
 
      if ( length < 0 ) {
        perror( "read" );
      }  
 
      while ( i < length ) {

	/* wait for something to happen */

        struct inotify_event *event = ( struct inotify_event * ) &buffer[ i ];
	  
	  if ( event->mask & IN_CLOSE_WRITE) {
            if (event->mask & IN_ISDIR) {
              printf( "Someone wrote to directory %s.\n", event->name );
	    }
            else {
              if (strcmp(event->name,BIGPIC) == 0 || strcmp(event->name,THUMB) == 0 
                  || strcmp( event->name, BLURMASK) == 0 || strcmp (event->name, BLURREDIMG) == 0) {
 
                printf("Skipping self generated file %s \n", event->name);
              }
              else {
		/* a new image was written and closed, lets go */

                printf( "writing to %s completed\n", event->name );

		/* create thumbnail - for the moment ignore blurring for thumbnails */
                strcpy (command,CONVERT);
                strcat (command, dirnames[event->wd]);
                strcat (command, "/");
                strcat (command, event->name);
                strcat (command, CONVERTOPTIONS);
                strcat (command, dirnames[event->wd]);
                strcat (command, "/");
                strcat (command, THUMB);
                printf( "Executing %s\n", command);
                system (command);
		
		/* check if we need to blur this image */
		if (blurcheck[event->wd]) {			
		     
		     /* issue blur command */
		     strcpy (blurcmd,CONVERT);
                     strcat (blurcmd, dirnames[event->wd]);
                     strcat (blurcmd, "/");
                     strcat (blurcmd, event->name);
		     strcat (blurcmd, " ");
		     strcat (blurcmd, blurmask[event->wd]);
		     strcat (blurcmd, " ");
		     strcat (blurcmd, BLUROPTIONS);
		     strcat (blurcmd, " ");
		     strcat (blurcmd, dirnames[event->wd]);
                     strcat (blurcmd, "/");
                     strcat (blurcmd, BLURREDIMG);
		     printf ("We need to blur the image, executing %s\n", blurcmd);
		     system (blurcmd);
		     
		     strcpy (command, CP);
                     strcat (command, dirnames[event->wd]); 
                     strcat (command, "/");
                     strcat (command, BLURREDIMG);
                     strcat (command, " ");
                     strcat (command, dirnames[event->wd]);
                     strcat (command, "/");
                     strcat (command, BIGPIC);

		}
		else {   
		     /* no blurring needed - just copy new file to bigpic */
                     strcpy (command,CP);
                     strcat (command, dirnames[event->wd]); 
                     strcat (command, "/");
                     strcat (command, event->name);
                     strcat (command, " ");
                     strcat (command, dirnames[event->wd]);
                     strcat (command, "/");
                     strcat (command, BIGPIC);
                }
		printf ("Executing %s\n", command);
                system (command);
	      }
	    }
          }
 
 
          i += EVENT_SIZE + event->len;
        }
      }
    
 
  /* Clean up*/
  inotify_rm_watch( fd, wd );
  close( fd );
   
  return 0;
}

